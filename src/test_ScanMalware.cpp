#include "ScanMalware.h"
#include "QuarantineManager.h"

extern "C" {
    #include "ini.h"
    #include <yara.h>
}
#include "INIReader.h"

#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <iomanip>
#include <openssl/evp.h>
#include <sqlite3.h>
#include <unistd.h> // readlink 사용을 위해 추가
#include <limits.h> // PATH_MAX 사용을 위해 추가

using namespace std;
namespace fs = std::filesystem;

// 실행 파일 위치를 기준으로 상대 경로를 계산하는 유틸 함수
static fs::path getBinaryRelativePath(const fs::path& relativePath) {
    char result[PATH_MAX];
    ssize_t count = readlink("/proc/self/exe", result, PATH_MAX);
    if (count == -1) {
        std::cerr << "ERROR: Could not get executable path for relative path calculation." << std::endl;
        return relativePath; // 실패 시 원래 경로 반환 또는 오류 처리
    }
    fs::path binaryPath = fs::path(std::string(result, count)).parent_path();
    return binaryPath / relativePath;
}


ScanMalware::ScanMalware(string dir, vector<string> exceptionDir, long long maxSize)
    : m_dir(move(dir)), m_exceptionDir(move(exceptionDir)), m_maxSize(maxSize)
{
    // 악성코드 해시 DB 열기
    const string kDbPath = getBinaryRelativePath("../db/hash.db").string();
    if (sqlite3_open(kDbPath.c_str(), &m_db) != SQLITE_OK)
    {
        cerr << "SQLite open error: " << sqlite3_errmsg(m_db) << endl;
        m_db = nullptr;
    }

    // YARA 초기화
    if (yr_initialize() != ERROR_SUCCESS)
    {
        cerr << "YARA init failed" << endl;
        return;
    }

    // YARA 컴파일러 생성
    YR_COMPILER* compiler = nullptr;
    if (yr_compiler_create(&compiler) != ERROR_SUCCESS)
    {
        cerr << "YARA compiler create failed" << endl;
        return;
    }

    // 룰 디렉토리 지정(바이너리 기준 상대 경로 사용)
    string ruleDir = getBinaryRelativePath("./rules").string();

    // 룰 디렉토리가 존재하고 디렉토리인지 확인
    if (!fs::exists(ruleDir) || !fs::is_directory(ruleDir)) {
        cerr << "Warning: YARA rule directory not found or is not a directory: " << ruleDir << endl;
        m_yaraRules = nullptr; // 룰 디렉토리 없으면 YARA 룰 로드 실패 처리
        yr_compiler_destroy(compiler);
        return;
    }

    // 모든 .yar 룰 파일 컴파일 시도
    for (const auto& entry : fs::directory_iterator(ruleDir))
    {
        if (!entry.is_regular_file() || entry.path().extension() != ".yar") continue;

        string rulePath = entry.path().string();
        FILE* ruleFile = fopen(rulePath.c_str(), "r");
        if (!ruleFile) {
            cerr << "Warning: Could not open YARA rule file: " << rulePath << endl;
            continue;
        }

        // 컴파일 실패한 룰만 로그 출력하고 무시
        if (yr_compiler_add_file(compiler, ruleFile, nullptr, rulePath.c_str()) != 0)
        {
            cerr << "Failed to compile YARA rule: " << rulePath << endl;
        }

        fclose(ruleFile);
    }

    // 컴파일된 룰을 rules 객체로 추출
    if (yr_compiler_get_rules(compiler, &m_yaraRules) != ERROR_SUCCESS)
    {
        cerr << "Failed to get YARA rules from compiler" << endl;
        m_yaraRules = nullptr;
    }

    // 컴파일러 객체 제거
    yr_compiler_destroy(compiler);
}

ScanMalware::~ScanMalware()
{
    if (m_db) sqlite3_close(m_db);
    if (m_yaraRules) yr_rules_destroy(m_yaraRules);
    yr_finalize();
}

void ScanMalware::run()
{
    // 격리 설정 파일에서 enable 여부 확인
    string quarantineConfigPath = getBinaryRelativePath("../conf/SIGQuarantine.ini").string();
    INIReader quarantineReader(quarantineConfigPath);

    bool shouldQuarantine = false;
    string quarantineDir = "./quarantine_zone";
    string metadataDbPath = "./db/quarantine_metadata.db";

    if (quarantineReader.ParseError() == 0) {
        shouldQuarantine = quarantineReader.GetBoolean("Quarantine", "enable", false);
        quarantineDir = quarantineReader.Get("Quarantine", "directory", quarantineDir);
        metadataDbPath = quarantineReader.Get("Quarantine", "database", metadataDbPath);
        quarantineDir = getBinaryRelativePath(quarantineDir).string();
        metadataDbPath = getBinaryRelativePath(metadataDbPath).string();

    } else {
        cerr << "Warning: Failed to parse SIGQuarantine.ini at " << quarantineConfigPath << ". Using default quarantine settings." << endl;
    }

    // 검사 대상 디렉토리 순회
    // m_dir이 유효한 디렉토리인지 확인
    if (!fs::exists(m_dir) || !fs::is_directory(m_dir)) {
        cerr << "ERROR: Scan directory not found or is not a directory: " << m_dir << endl;
        return; // 유효하지 않은 디렉토리면 검사 중단
    }

    for (const auto& entry : fs::recursive_directory_iterator(m_dir))
    {
        // 오류 발생 시 건너뛰기
        error_code ec;
        if (!entry.is_regular_file(ec)) {
            if (ec) {
                 cerr << "Warning: Error accessing file " << entry.path() << ": " << ec.message() << endl;
            }
            continue;
        }

        string filePath = entry.path().string();
        long long fileSize = entry.file_size(ec);
         if (ec) {
             cerr << "Warning: Error getting file size for " << entry.path() << ": " << ec.message() << endl;
             continue; // 파일 크기 가져오기 실패 시 건너뛰기
         }


        // 예외 디렉토리 여부 확인
        bool isExcluded = false;
        for (const auto& excludeDir : m_exceptionDir)
        {
            // 정규화된 경로를 사용하여 비교 정확도 높이기
            fs::path normalizedFilePath = fs::canonical(filePath, ec);
            if (ec) {
                 cerr << "Warning: Error normalizing path " << filePath << ": " << ec.message() << endl;
                 // 정규화 실패 시 원본 경로로 비교 시도
                 if (filePath.rfind(excludeDir, 0) == 0) {
                     isExcluded = true;
                     break;
                 }
            } else {
                 fs::path normalizedExcludeDir = fs::canonical(excludeDir, ec);
                 if (ec) {
                     cerr << "Warning: Error normalizing exclude path " << excludeDir << ": " << ec.message() << endl;
                     // 정규화 실패 시 원본 경로로 비교 시도
                     if (filePath.rfind(excludeDir, 0) == 0) {
                         isExcluded = true;
                         break;
                     }
                 } else {
                    if (normalizedFilePath.string().rfind(normalizedExcludeDir.string(), 0) == 0) // excludeDir로 시작하는 경우
                    {
                        isExcluded = true;
                        break;
                    }
                 }
            }
        }

        // 예외 또는 파일 크기 초과 시 검사 제외
        if (isExcluded || fileSize > m_maxSize) continue;

        ++m_totalScannedFiles;

        // 해시 기반 탐지
        DetectResult result = detectByHash(filePath);

        // 해시 탐지 실패 시 YARA 검사
        if (!result.detected)
        {
            result = matchYaraRules(filePath);
        }

        // 탐지되었으면 결과 저장 (격리 여부는 나중에 QuarantineManager에서 업데이트)
        if (result.detected)
        {
            // quarantined 필드는 초기에는 false로 설정
            m_detectionResults.push_back({ filePath, result.cause, result.malwareName, fileSize, false });
        }
    }

    // 격리 설정이 활성화되어 있고 탐지된 항목이 있을 경우
    if (shouldQuarantine && !m_detectionResults.empty())
    {
        // QuarantineManager 인스턴스 생성
        QuarantineManager qm;

        // 격리 수행 (Run 메서드에 탐지 결과 벡터, 격리 디렉토리, DB 경로 전달)
        qm.Run(m_detectionResults, quarantineDir, metadataDbPath);

        // QuarantineManager::Run 내부에서 m_detectionResults 벡터의 quarantined 필드가 업데이트됨(별도로 결과를 받아와 반영할 필요 없음)
    }
}


int ScanMalware::getTotalScannedFiles() const
{
    return m_totalScannedFiles;
}

int ScanMalware::getDetectedFiles() const
{
    return static_cast<int>(m_detectionResults.size());
}

int ScanMalware::getQuarantinedFiles() const
{
    int count = 0;
    for (const auto& r : m_detectionResults)
        if (r.quarantined) ++count;
    return count;
}

// main.cpp에서 격리 결과를 업데이트할 수 있도록 non-const 참조 반환
vector<DetectionResultRecord>& ScanMalware::getDetectionResults()
{
    return m_detectionResults;
}

DetectResult ScanMalware::detectByHash(const string& filePath)
{
    // 사용할 해시 알고리즘 목록
    const vector<string> kAlgorithms = { "md5", "sha1", "sha256" };

    // DB 미초기화 시 탐지 실패 처리
    if (!m_db)
    {
        cerr << "SQLite not initialized." << endl;
        return { false, "", "" };
    }

    // 해시 탐지를 위한 SQL 쿼리 템플릿
    const string kQuery = "SELECT name FROM malware_hashes WHERE algo = ? AND hash = ?";
    sqlite3_stmt* stmt = nullptr;
    DetectResult result = { false, "", "" };

    // 각 알고리즘에 대해 순차적으로 해시 검사
    for (const auto& algo : kAlgorithms)
    {
        // 대상 파일의 해시값 계산
        string hashValue = computeHash(filePath, algo);
        if (hashValue.empty()) continue;

        // SQL 쿼리 준비
        if (sqlite3_prepare_v2(m_db, kQuery.c_str(), -1, &stmt, nullptr) != SQLITE_OK)
        {
            cerr << "SQLite prepare error: " << sqlite3_errmsg(m_db) << endl;
            continue;
        }

        // 쿼리 파라미터 바인딩: 1 → 알고리즘, 2 → 해시값
        sqlite3_bind_text(stmt, 1, algo.c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 2, hashValue.c_str(), -1, SQLITE_STATIC);

        // 결과 확인: 매칭되는 악성 해시가 있으면 탐지 성공 처리
        if (sqlite3_step(stmt) == SQLITE_ROW)
        {
            string malwareName = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0));
            result = { true, algo, malwareName };
            sqlite3_finalize(stmt); // 매칭 시 즉시 리소스 정리하고 루프 종료
            break;
        }

        // 매칭 실패한 경우에도 리소스 해제
        sqlite3_finalize(stmt);
        stmt = nullptr;
    }

    return result;
}

string ScanMalware::computeHash(const string& filePath, const string& algo)
{
    // 선택한 해시 알고리즘에 대응하는 OpenSSL digest 함수 포인터
    const EVP_MD* md = nullptr;
    if (algo == "md5") md = EVP_md5();
    else if (algo == "sha1") md = EVP_sha1();
    else if (algo == "sha256") md = EVP_sha256();

    if (!md) {
        cerr << "ERROR: Unsupported hash algorithm: " << algo << endl;
        return "";
    }

    // Digest 컨텍스트 생성
    EVP_MD_CTX* ctx = EVP_MD_CTX_new();
    if (!ctx) {
        cerr << "ERROR: Failed to create EVP_MD_CTX." << endl;
        return ""; // 메모리 부족 등 오류 시 실패 처리
    }

    // 바이너리 모드로 파일 열기
    ifstream file(filePath, ios::binary);
    if (!file.is_open())
    {
        EVP_MD_CTX_free(ctx);
        return ""; // 파일 열기 실패 시 빈 문자열 반환
    }

    // Digest 초기화
    EVP_DigestInit_ex(ctx, md, nullptr);

    // 파일을 4KB씩 읽으며 해시 갱신
    const int kBufferSize = 4096;
    char buffer[kBufferSize];
    while (file)
    {
        file.read(buffer, sizeof(buffer));
        streamsize bytesRead = file.gcount();
        if (bytesRead > 0)
            EVP_DigestUpdate(ctx, buffer, bytesRead);
    }

    // 최종 해시 계산
    unsigned char hash[EVP_MAX_MD_SIZE];
    unsigned int length = 0;
    EVP_DigestFinal_ex(ctx, hash, &length);


    // 컨텍스트 해제
    EVP_MD_CTX_free(ctx);

    // 결과를 hex 문자열로 변환
    stringstream ss;
    for (unsigned int i = 0; i < length; ++i)
        ss << hex << setw(2) << setfill('0') << static_cast<int>(hash[i]);
    ss << std::dec;

    return ss.str();
}


int yara_callback(int msg, void* message_data, void* user_data)
{
    if (msg == CALLBACK_MSG_RULE_MATCHING)
    {
        const YR_RULE* rule = static_cast<const YR_RULE*>(message_data);
        string* result = static_cast<string*>(user_data);
        *result = rule->identifier;
        return CALLBACK_ABORT;
    }
    return CALLBACK_CONTINUE;
}

DetectResult ScanMalware::matchYaraRules(const string& filePath)
{
    if (!m_yaraRules)
    {
        cerr << "YARA rules not initialized." << endl;
        return { false, "", "" };
    }

    YR_SCANNER* scanner = nullptr;
    string matchedRule; // 콜백 함수에서 매칭된 룰 이름을 저장할 변수

    if (yr_scanner_create(m_yaraRules, &scanner) != ERROR_SUCCESS)
    {
        cerr << "Failed to create YARA scanner" << endl;
        return { false, "", "" };
    }

    // 콜백 함수 및 사용자 데이터 설정
    yr_scanner_set_callback(scanner, yara_callback, &matchedRule);

    // 파일 스캔 실행
    int scan_result = yr_scanner_scan_file(scanner, filePath.c_str(), 0); // flags = 0
    if (scan_result != ERROR_SUCCESS)
    {
        cerr << "YARA scan failed for file: " << filePath << endl;
        yr_scanner_destroy(scanner);
        return { false, "", "" };
    }

    yr_scanner_destroy(scanner);

    // 탐지 결과가 있으면 결과 반환
    if (!matchedRule.empty())
        return { true, "yara", matchedRule };

    return { false, "", "" };
}

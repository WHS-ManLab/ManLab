#include "MalwareScan.h"
#include "Paths.h"
#include "StringUtils.h"
#include "UserNotifier.h" 
#include "INIReader.h"
#include <fstream>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <iomanip>
#include <openssl/evp.h>
#include <sqlite3.h>
#include <indicator.hpp>
#include <thread> // std::this_thread::sleep_for
#include <chrono> // std::chrono::milliseconds
#include <sys/xattr.h>
#include <spdlog/spdlog.h>

using namespace std;
namespace fs = std::filesystem;
using manlab::utils::trim;

static const std::vector<std::string> kSystemExcluded = {
    "/proc", "/sys", "/dev", "/run",
    "/tmp", "/var/run", "/var/tmp",
    "/boot", "/mnt", "/media", "/lost+found",
    "/lib", "/lib64", "/usr/lib", "/usr/lib64",
    "/root/ManLab"  // ManLab 자체 디렉터리 (설정, 로그, 바이너리 등)
};

/*

초기화 관련 함수

*/
MalwareScan::MalwareScan()
    : mMode(Mode::Manual),
      mDir("/home"),
      mMaxSize(100LL * 1024 * 1024),
      mbShouldQuarantine(false),
      mTotalScannedFiles(0),
      mHashStorage(nullptr),
      mYaraRules(nullptr)
{}

MalwareScan::~MalwareScan()
{
    if (mYaraRules) 
    {
        yr_rules_destroy(mYaraRules);
    }

    yr_finalize();   // yr_initialize 대응
}

bool MalwareScan::Init()
{
    spdlog::info("MalwareScan 초기화 시작");
    // ini 파싱 (Scan·Exclude·Limit·Quarantine)
    INIReader reader(PATH_MALSCAN_CONFIG_INI);
    if (reader.ParseError() == 0)
    {
        mDir = trim(reader.Get("Scan", "paths", "/home"));

        // 제외 디렉터리 파싱
        mExceptionDir.clear();
        {
            mExceptionDir = kSystemExcluded; 
            std::stringstream ss(reader.Get("Exclude", "paths", ""));
            std::string token;
            while (std::getline(ss, token, ','))
            {
                std::string cleaned = trim(token);
                if (!cleaned.empty())
                {
                    mExceptionDir.push_back(cleaned);
                    spdlog::debug("스캔 제외 경로 추가: {}", cleaned);
                }
            }
        }

        long long userMb = reader.GetInteger("Limit", "max_size", 100);
        long long finalMb = std::min(userMb, 100LL);  // 100MB 초과 방지
        mMaxSize = finalMb * 1024 * 1024;

        spdlog::debug("최대 파일 크기 제한 설정: 사용자 요청 = {}MB, 적용된 제한 = {}MB", userMb, finalMb);
        mbShouldQuarantine =
            trim(reader.Get("Quarantine", "enable", "false")) == "true";
            spdlog::debug("격리 기능 활성화 여부: {}", mbShouldQuarantine);
    }
    else 
    {
        spdlog::warn("설정 파일 파싱 실패: {} — 기본값으로 초기화.", PATH_MALSCAN_CONFIG_INI);
        mDir = "/home";
        mExceptionDir = kSystemExcluded;
        mMaxSize = 100LL * 1024 * 1024;
        mbShouldQuarantine = false;

        spdlog::info("기본 스캔 경로: {}", mDir);
        spdlog::info("기본 최대 파일 크기 제한: {}MB", mMaxSize / 1024 / 1024);
        spdlog::info("격리 기능: 비활성화");
    }

    // Hash storage 연결
    mHashStorage = &DBManager::GetInstance().GetHashStorage();

    // YARA 초기화·컴파일
    if (yr_initialize() != ERROR_SUCCESS)
    {
        spdlog::error("YARA 초기화 실패: yr_initialize()");
        return false;
    }

    YR_COMPILER* compiler = nullptr;
    if (yr_compiler_create(&compiler) != ERROR_SUCCESS)
    {
        spdlog::error("YARA 컴파일러 생성 실패: yr_compiler_create()");
        return false;   
    }

    for (const auto& entry : fs::directory_iterator(PATH_RULES))
    {
        if (!entry.is_regular_file()) 
        {
            continue;
        }

        FILE* fp = fopen(entry.path().c_str(), "r");
        if (!fp) 
        {
            spdlog::warn("YARA 룰 파일 열기 실패: {}", entry.path().string());
            continue;
        }

        int result = yr_compiler_add_file(compiler, fp, nullptr, entry.path().c_str());
        fclose(fp);

        if (result != 0)
        {
            spdlog::warn("YARA 룰 컴파일 실패: {}", entry.path().string());
        }
        else
        {
            spdlog::debug("YARA 룰 추가 완료: {}", entry.path().string());
        }
    }

    if (yr_compiler_get_rules(compiler, &mYaraRules) != ERROR_SUCCESS)
    {
        spdlog::error("YARA 룰 객체 생성 실패: yr_compiler_get_rules()");
        yr_compiler_destroy(compiler);
        return false;
    }

    yr_compiler_destroy(compiler);
    spdlog::info("MalwareScan 초기화 완료");
    return true;
}

void MalwareScan::SetMode(Mode mode)
{
    mMode = mode;
}

void MalwareScan::Reset()
{
    mStartTime = {};
    mEndTime   = {};
    mDetected.clear();
    mQuarantineResults.clear();
    mTotalScannedFiles = 0;
    mReport.clear();
}

/*

실행 관련 함수

*/
void MalwareScan::Run(std::ostream* pOut)
{
    Reset();  // 검사 상태 초기화
    mStartTime = std::chrono::system_clock::now();

    spdlog::info("악성코드 검사 시작, 대상 경로: {}", mDir);

    std::vector<fs::directory_entry> entries;
    collectTargetFiles(entries);

    const size_t totalFiles = entries.size();
    if (totalFiles == 0) 
    {
        spdlog::warn("ELF 파일이 존재하지 않아 검사 종료, 경로: {}", mDir);
        if (pOut) 
        {
            *pOut << "\033[31m[!] 지정한 경로에 ELF 파일이 존재하지 않습니다. " << mDir << "\033[0m\n";
        }
        mEndTime = std::chrono::system_clock::now();
        mReport = GenerateReportString();
        return;
    }

    spdlog::info("총 {}개의 ELF 파일이 발견되어 검사 시작", totalFiles);

    // 진행률 바
    indicators::ProgressBar bar{
        indicators::option::BarWidth{50},
        indicators::option::Start{"["},
        indicators::option::Fill{"="},
        indicators::option::Lead{">"},
        indicators::option::Remainder{"-"},
        indicators::option::End{"]"},
        indicators::option::ForegroundColor{indicators::Color::green},
        indicators::option::ShowPercentage{true},
        indicators::option::ShowElapsedTime{true},
        indicators::option::ShowRemainingTime{true},
        indicators::option::Stream{(pOut ? *pOut : std::cout)},
        indicators::option::PostfixText{""}
    };

    bar.set_progress(0);

    if (pOut)
    {
        *pOut << "\n";     // 프로그레스 바 아래 경로 표시 줄 확보
        *pOut << "\033[s"; // 현재 커서(바 위치) 저장
    }

    // 검사 루프
    size_t current = 0;
    for (const auto& entry : entries) {
        ++mTotalScannedFiles;
        ++current;

        const std::string filePath = entry.path().string();
        const long long fileSize = entry.file_size();

        if (pOut) 
        {
            float percent = 100.0f * current / totalFiles;

            // 1) 저장된 위치로 복귀 → 바 줄
            *pOut << "\033[u"   // bar line
                  << "\r";      // line start

            bar.set_progress(percent); // 바 갱신

            // 2) 경로 줄 갱신
            *pOut << "\033[1B"        // 한 줄 아래(경로 줄)
                  << "\r\033[2K"      // 줄 전체 지움
                  << "Scanning: " << filePath << std::flush;

            // 3) 다시 바 줄로 올라가고 위치 재저장
            *pOut << "\033[1A"  // 위로 (bar 줄)
                  << "\r";
            *pOut << "\033[s";  // 다음 루프를 위한 저장
        }

        DetectResult result = analyzeFile(entry.path());
        if (result.detected) {
            mDetected.push_back({ filePath, result.cause, result.malwareName, fileSize });

            spdlog::info("악성코드 탐지. 파일: {}, 원인: {}, 이름: {}", filePath, result.cause, result.malwareName);

            bool quarantined = false;
            if (mbShouldQuarantine) 
            {
                quarantined = tryQuarantine(entry.path(), result);
                spdlog::debug("격리 {} , 파일: {}", quarantined ? "성공" : "실패", filePath);
            }
            mQuarantineResults.push_back(quarantined);
        }
    }

    if (pOut) {
        // 마무리: 바 줄/경로 줄 정리
        *pOut << "\033[u"    // bar 줄
              << "\r\033[2K" // 바 지우기
              << "\033[1B"   // 경로 줄
              << "\r\033[2K"; // 경로 지우기
    }

    mEndTime = std::chrono::system_clock::now();
    mReport = GenerateReportString(); // 후처리 리포트 생성

    spdlog::info("악성코드 검사 종료 – 총 검사 파일 수: {}, 탐지 수: {}", mTotalScannedFiles, mDetected.size());
}

void MalwareScan::collectTargetFiles(std::vector<fs::directory_entry>& entries)
{
    try {
        for (auto it = fs::recursive_directory_iterator(
                 mDir, fs::directory_options::skip_permission_denied);
             it != fs::recursive_directory_iterator(); ++it)
        {
            const auto& entry = *it;
            const std::string filePath = entry.path().string();

            bool excluded = false;
            for (const auto& ex : mExceptionDir) 
            {
                if (filePath.rfind(ex, 0) == 0) 
                {
                    excluded = true;
                    break;
                }
            }

            if (excluded) 
            {
                if (entry.is_directory())
                    it.disable_recursion_pending();
                continue;
            }

            if (!entry.is_regular_file()) continue;
            if (isELF(filePath)) entries.push_back(entry);
        }
    } catch (const fs::filesystem_error& e) {
        // 로그 또는 출력은 Run()에서 처리
    }
}

DetectResult MalwareScan::analyzeFile(const fs::path& path)
{
    DetectResult result = detectByHash(path.string());
    if (!result.detected) 
    {
        result = matchYaraRules(path.string());
    }
    return result;
}

bool MalwareScan::tryQuarantine(const fs::path& path, const DetectResult& dr)
{
    ScanInfo info
    {
        .path  = path.string(),
        .cause = dr.cause,
        .name  = dr.malwareName,
        .size  = static_cast<long long>(fs::file_size(path))
    };

    std::vector<ScanInfo> targets{info};
    QuarantineManager qm(targets);

    qm.Run();
    const auto& results = qm.GetIsQuarantineSuccess();
    return !results.empty() && results[0];
}

bool MalwareScan::isELF(const std::string& path)
{
    std::ifstream f(path, std::ios::binary);
    if (!f) return false;

    unsigned char magic[4]{};
    f.read(reinterpret_cast<char*>(magic), 4);
    return magic[0] == 0x7f &&
           magic[1] == 'E' &&
           magic[2] == 'L' &&
           magic[3] == 'F';
}

DetectResult MalwareScan::detectByHash(const std::string& filePath)
{
    static const std::vector<std::string> kAlgorithms = { "md5", "sha1", "sha256" };
    DetectResult result { false, "", "", "" }; 

    if (!mHashStorage)
    {
        return result;
    }

    for (const auto& algo : kAlgorithms)
    {
        std::string hashValue = computeHash(filePath, algo);
        if (hashValue.empty()) continue;

        auto matches = mHashStorage->get_all<MalwareHashDB>(
            sqlite_orm::where(
                sqlite_orm::c(&MalwareHashDB::Algorithm) == algo &&
                sqlite_orm::c(&MalwareHashDB::Hash) == hashValue
            )
        );

        if (!matches.empty())
        {
            result = { true, algo, matches[0].MalwareName, hashValue }; 
            break;
        }
    }
    return result;
}

std::string MalwareScan::computeHash(const std::string& filePath, const std::string& algo)
{
    const EVP_MD* md = nullptr;
    if (algo == "md5") md = EVP_md5();
    else if (algo == "sha1") md = EVP_sha1();
    else if (algo == "sha256") md = EVP_sha256();

    EVP_MD_CTX* ctx = EVP_MD_CTX_new();
    if (!ctx) return "";

    std::ifstream file(filePath, std::ios::binary);
    if (!file.is_open())
    {
        EVP_MD_CTX_free(ctx);
        return "";
    }

    EVP_DigestInit_ex(ctx, md, nullptr);

    const int kBufferSize = 4096;
    char buffer[kBufferSize];
    while (file)
    {
        file.read(buffer, sizeof(buffer));
        std::streamsize bytesRead = file.gcount();
        if (bytesRead > 0)
        {
            EVP_DigestUpdate(ctx, buffer, bytesRead);
        }
    }

    unsigned char hash[EVP_MAX_MD_SIZE];
    unsigned int length = 0;
    EVP_DigestFinal_ex(ctx, hash, &length);
    EVP_MD_CTX_free(ctx);

    std::stringstream ss;
    for (unsigned int i = 0; i < length; ++i)
    {
        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(hash[i]);
    }
    ss << std::dec;
    return ss.str();
}

static int yara_callback(int msg, void* message_data, void* user_data)
{
    if (msg == CALLBACK_MSG_RULE_MATCHING)
    {
        const YR_RULE* rule = static_cast<const YR_RULE*>(message_data);
        std::string* result = static_cast<std::string*>(user_data);
        *result = rule->identifier;
        return CALLBACK_ABORT;
    }
    return CALLBACK_CONTINUE;
}

DetectResult MalwareScan::matchYaraRules(const std::string& filePath)
{
    if (!mYaraRules)
    {
        return { false, "", "", "" }; 
    }

    YR_SCANNER* scanner = nullptr;
    std::string matchedRule;

    if (yr_scanner_create(mYaraRules, &scanner) != ERROR_SUCCESS)
    {
        return { false, "", "", "" };
    }

    yr_scanner_set_callback(scanner, yara_callback, &matchedRule);

    if (yr_scanner_scan_file(scanner, filePath.c_str()) != ERROR_SUCCESS)
    {
        yr_scanner_destroy(scanner);
        return { false, "", "", "" };
    }

    yr_scanner_destroy(scanner);

    if (!matchedRule.empty())
    {
        return { true, "yara", matchedRule, "" }; 
    }

    return { false, "", "", "" };
}



/*

리포트 및 DB저장

*/
std::string MalwareScan::GenerateReportString()
{
    std::ostringstream ss;

    // 1. 시작 시각
    time_t tStart = std::chrono::system_clock::to_time_t(mStartTime);
    char buf[20];
    strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", localtime(&tStart));
    ss << "[Scan Type] ";

    switch (mMode) 
    {
        case Mode::Manual:    ss << "Manual"; break;
        case Mode::Scheduled: ss << "Scheduled"; break;
        case Mode::Realtime:  ss << "Realtime"; break;
    }
    ss << "\n[Scan Time] " << buf;
    ss << "\n[Scanned Path] " << mDir;

    // 2. 탐지 파일 출력
    ss << "\n\n[Detected Files]";
    for (size_t i = 0; i < mDetected.size(); ++i) {
        const auto& info = mDetected[i];
        bool quarantined = (i < mQuarantineResults.size()) ? mQuarantineResults[i] : false;

        ss << "\n  " << (i + 1) << ". File: " << info.path;

        time_t detectedAt = std::chrono::system_clock::to_time_t(mEndTime);
        strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", localtime(&detectedAt));
        ss << "\n     Detected At: " << buf;
        ss << "\n     Quarantine: " << (quarantined ? "Success" : "Failed");
        ss << "\n     Reason: " << info.cause << " match";

        if (info.cause == "yara")
            ss << "\n     Rule Name: " << info.name;
        else {
            ss << "\n     Hash: " << info.name.substr(0, 24) << "...";
            ss << "\n     Malware Name: " << info.name;
        }

        ss << "\n     Original Size: " << info.size << " bytes";
    }

    // 3. 요약
    ss << "\n\n[Summary]";
    ss << "\nScanned Files: " << mTotalScannedFiles;
    ss << "\nInfected Files: " << mDetected.size();
    ss << "\nQuarantined Files: " << std::count(mQuarantineResults.begin(), mQuarantineResults.end(), true);

    auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(mEndTime - mStartTime).count();
    ss << "\nElapsed Time: " << (elapsed / 60) << ":" << std::setw(2) << std::setfill('0') << (elapsed % 60);
    ss << "\n";

    return ss.str();
}

void MalwareScan::PrintReport(std::ostream& out) const
{
    out << mReport;
}

void MalwareScan::SendNotification() const
{
    const int detected = static_cast<int>(mDetected.size());

    // 수동 검사일 경우 알림 전송 안 함
    if (mMode == Mode::Manual)
    {
        spdlog::debug("수동 검사, 알림을 전송하지 않음.");
        return;
    }
    // 실시간 검사인데 탐지 안 됨 → 전송 안 함
    if (mMode == Mode::Realtime && detected == 0)
    {
        spdlog::debug("실시간 검사, 탐지된 악성코드가 없음.");
        return;
    }

    std::string title;
    std::string message;

    if (mMode == Mode::Scheduled)
    {
        if (detected == 0)
        {
            title = "ManLab 예약 검사 완료";
            message = "악성코드가 탐지되지 않았습니다.";
            UserNotifier::NotifyAll(title, message);
            spdlog::info("예약 검사 알림 전송: 탐지 없음");
        }
        else
        {
            title = "ManLab 예약 검사 경고";
            message = "총 " + std::to_string(detected) + "개의 악성코드가 탐지되었습니다.";
            UserNotifier::NotifyAllUrgent(title, message);
            spdlog::info("예약 검사 알림 전송: {}개 탐지됨", detected);
        }
    }
    else if (mMode == Mode::Realtime)
    {
        title = "ManLab 실시간 탐지 경고";
        message = "총 " + std::to_string(detected) + "개의 악성코드가 탐지되었습니다.";
        UserNotifier::NotifyAllUrgent(title, message);
        spdlog::info("실시간 검사 알림 전송: {}개 탐지됨", detected);
    }
}

void MalwareScan::SaveReportToDB()
{
    std::string typeStr;
    switch (mMode) 
    {
        case Mode::Manual:    typeStr = "manual"; break;
        case Mode::Scheduled: typeStr = "scheduled"; break;
        case Mode::Realtime:  typeStr = "realtime"; break;
        default :             typeStr = "manual"; break;
    }

    time_t t = std::chrono::system_clock::to_time_t(mEndTime);
    char buf[20];
    strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", localtime(&t));
    bool hasMalware = !mDetected.empty();

    // ScanReport 삽입
    DBManager::GetInstance().GetScanReportStorage().insert(
        ScanReport {
            0,
            typeStr,
            std::string(buf),
            mReport,
            !mDetected.empty()
        }
    );

    spdlog::info("검사 결과 DB 저장 완료, 유형: {}, 감염됨: {}", typeStr, hasMalware ? "예" : "아니오");
}

bool MalwareScan::RunSingleFile(const std::string& path, bool shouldQuarantine)
{
    Reset();
    mMode = Mode::Realtime;
    mDir = path;  // 단일 파일 경로를 저장
    mStartTime = std::chrono::system_clock::now();

    // 파일 유형 확인
    if (!isELF(path)) 
    {
        spdlog::warn("ELF 파일이 아님 – 실시간 검사 제외: {}", path);
        return false;
    }

    ++mTotalScannedFiles;

    // 탐지 수행
    DetectResult result = analyzeFile(path);
    bool isMalicious = result.detected;

    if (isMalicious)
    {
        long long fileSize = static_cast<long long>(fs::file_size(path));
        mDetected.push_back({ path, result.cause, result.malwareName, fileSize });

        spdlog::info("악성코드 탐지 . 파일: {}, 원인: {}, 이름: {}", path, result.cause, result.malwareName);
        
        bool quarantined = false;
        if (shouldQuarantine)
        {
            quarantined = tryQuarantine(path, result);
            spdlog::debug("격리 {} , 파일: {}", quarantined ? "성공" : "실패", path);
        }
        mQuarantineResults.push_back(quarantined);
    }
    else
    {
        spdlog::debug("악성코드 미탐지 , 파일: {}", path);
        return isMalicious;
    }

    mEndTime = std::chrono::system_clock::now();
    mReport = GenerateReportString();

    SendNotification();
    SaveReportToDB();

    spdlog::info("실시간 검사 종료 . 결과: 감염됨 = {}", isMalicious ? "예" : "아니오");

    return isMalicious;
}
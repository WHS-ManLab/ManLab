#include "MalwareScan.h"
#include "Paths.h"
#include "StringUtils.h"
#include "UserNotifier.h" 
#include "INIReader.h"
#include <fstream>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <iomanip>
#include <openssl/evp.h>
#include <sqlite3.h>
#include <indicator.hpp>
#include <thread> // std::this_thread::sleep_for
#include <chrono> // std::chrono::milliseconds

using namespace std;
namespace fs = std::filesystem;
using manlab::utils::trim;

static const std::vector<std::string> kSystemExcluded = {
    "/proc", "/sys", "/dev", "/run",
    "/tmp", "/var/run", "/var/tmp"
};

/*

초기화 관련 함수

*/
MalwareScan::MalwareScan()
    : mMode(Mode::Manual),
      mDir("/home"),
      mMaxSize(100LL * 1024 * 1024),
      mbShouldQuarantine(false),
      mTotalScannedFiles(0),
      mHashStorage(nullptr),
      mYaraRules(nullptr)
{}

MalwareScan::~MalwareScan()
{
    if (mYaraRules) 
    {
        yr_rules_destroy(mYaraRules);
    }

    yr_finalize();   // yr_initialize 대응
}

void MalwareScan::Init()
{
    // ini 파싱 (Scan·Exclude·Limit·Quarantine)
    INIReader reader(PATH_MALSCAN_CONFIG_INI);
    if (reader.ParseError() == 0)
    {
        mDir = trim(reader.Get("Scan", "paths", "/home"));

        // 제외 디렉터리 파싱
        mExceptionDir.clear();
        {
            mExceptionDir = kSystemExcluded; 
            std::stringstream ss(reader.Get("Exclude", "paths", ""));
            std::string token;
            while (std::getline(ss, token, ','))
            {
                std::string cleaned = trim(token);
                if (!cleaned.empty())
                    mExceptionDir.push_back(cleaned);
            }
        }

        long long mb = reader.GetInteger("Limit", "max_size", 100);
        mMaxSize = mb * 1024 * 1024;

        mbShouldQuarantine =
            trim(reader.Get("Quarantine", "enable", "false")) == "true";
    }

    // Hash storage 연결
    mHashStorage = &DBManager::GetInstance().GetHashStorage();

    // YARA 초기화·컴파일
    if (yr_initialize() != ERROR_SUCCESS)
        throw std::runtime_error("yr_initialize failed");

    YR_COMPILER* compiler = nullptr;
    if (yr_compiler_create(&compiler) != ERROR_SUCCESS)
        throw std::runtime_error("yr_compiler_create failed");

    for (const auto& entry : fs::directory_iterator(PATH_RULES))
    {
        if (!entry.is_regular_file()) continue;

        FILE* fp = fopen(entry.path().c_str(), "r");
        if (!fp) continue;

        yr_compiler_add_file(compiler, fp, nullptr, entry.path().c_str());
        fclose(fp);
    }

    if (yr_compiler_get_rules(compiler, &mYaraRules) != ERROR_SUCCESS)
        throw std::runtime_error("yr_compiler_get_rules failed");

    yr_compiler_destroy(compiler);
}

void MalwareScan::SetMode(Mode mode)
{
    mMode = mode;
}

void MalwareScan::Reset()
{
    mStartTime = {};
    mEndTime   = {};
    mDetected.clear();
    mQuarantineResults.clear();
    mTotalScannedFiles = 0;
    mReport.clear();
}



/*

실행 관련 함수

*/
void MalwareScan::Run(std::ostream* pOut)
{
    Reset();  // 검사 상태 초기화
    mStartTime = std::chrono::system_clock::now();

    std::vector<fs::directory_entry> entries;
    collectTargetFiles(entries);

    const size_t totalFiles = entries.size();
    if (totalFiles == 0) {
        if (pOut) {
            *pOut << "\033[31m[!] No ELF files found in " << mDir << "\033[0m\n";
        }
        mEndTime = std::chrono::system_clock::now();
        mReport = GenerateReportString();
        return;
    }

    // 진행률 바
    indicators::ProgressBar bar{
        indicators::option::BarWidth{50},
        indicators::option::Start{"["},
        indicators::option::Fill{"■"},
        indicators::option::Lead{">"},
        indicators::option::Remainder{"-"},
        indicators::option::End{"]"},
        indicators::option::ForegroundColor{indicators::Color::green},
        indicators::option::ShowPercentage{true},
        indicators::option::ShowElapsedTime{true},
        indicators::option::ShowRemainingTime{true},
        indicators::option::Stream{(pOut ? *pOut : std::cout)}
    };

    // 검사 루프
    size_t current = 0;
    for (const auto& entry : entries) {
        ++mTotalScannedFiles;
        ++current;

        const std::string filePath = entry.path().string();
        const long long fileSize = entry.file_size();

        if (pOut) 
        {
            float percent = 100.0f * current / totalFiles;
            bar.set_progress(percent);
            *pOut << "\n[*] Scanning: " << filePath << "\n";
            *pOut << "\033[2A"; // 바 + 경로 위로 이동
        }

        DetectResult result = analyzeFile(entry.path());
        if (result.detected) {
            mDetected.push_back({ filePath, result.cause, result.malwareName, fileSize });

            bool quarantined = false;
            if (mbShouldQuarantine) {
                quarantined = tryQuarantine(entry.path(), result);
            }
            mQuarantineResults.push_back(quarantined);
        }
    }

    if (pOut) *pOut << "\n\r\033[K"; // 바 마지막 줄 지움

    mEndTime = std::chrono::system_clock::now();
    mReport = GenerateReportString(); // 후처리 리포트 생성
}

void MalwareScan::collectTargetFiles(std::vector<fs::directory_entry>& entries)
{
    try {
        for (auto it = fs::recursive_directory_iterator(
                 mDir, fs::directory_options::skip_permission_denied);
             it != fs::recursive_directory_iterator(); ++it)
        {
            const auto& entry = *it;
            const std::string filePath = entry.path().string();

            bool excluded = false;
            for (const auto& ex : mExceptionDir) {
                if (filePath.rfind(ex, 0) == 0) {
                    excluded = true;
                    break;
                }
            }

            if (excluded) {
                if (entry.is_directory())
                    it.disable_recursion_pending();
                continue;
            }

            if (!entry.is_regular_file()) continue;
            if (isELF(filePath)) entries.push_back(entry);
        }
    } catch (const fs::filesystem_error& e) {
        // 로그 또는 출력은 Run()에서 처리
    }
}

DetectResult MalwareScan::analyzeFile(const fs::path& path)
{
    DetectResult result = detectByHash(path.string());
    if (!result.detected) {
        result = matchYaraRules(path.string());
    }
    return result;
}

bool MalwareScan::tryQuarantine(const fs::path& path, const DetectResult& dr)
{
    ScanInfo info{
        .path  = path.string(),
        .cause = dr.cause,
        .name  = dr.malwareName,
        .size  = static_cast<long long>(fs::file_size(path))
    };

    std::vector<ScanInfo> targets{info};
    QuarantineManager qm(targets);

    qm.Run();
    const auto& results = qm.GetIsQuarantineSuccess();
    return !results.empty() && results[0];
}

bool MalwareScan::isELF(const std::string& path)
{
    std::ifstream f(path, std::ios::binary);
    if (!f) return false;

    unsigned char magic[4]{};
    f.read(reinterpret_cast<char*>(magic), 4);
    return magic[0] == 0x7f &&
           magic[1] == 'E' &&
           magic[2] == 'L' &&
           magic[3] == 'F';
}

DetectResult MalwareScan::detectByHash(const std::string& filePath)
{
    static const std::vector<std::string> kAlgorithms = { "md5", "sha1", "sha256" };
    DetectResult result { false, "", "", "" }; 

    if (!mHashStorage)
    {
        return result;
    }

    for (const auto& algo : kAlgorithms)
    {
        std::string hashValue = computeHash(filePath, algo);
        if (hashValue.empty()) continue;

        auto matches = mHashStorage->get_all<MalwareHashDB>(
            sqlite_orm::where(
                sqlite_orm::c(&MalwareHashDB::Algorithm) == algo &&
                sqlite_orm::c(&MalwareHashDB::Hash) == hashValue
            )
        );

        if (!matches.empty())
        {
            result = { true, algo, matches[0].MalwareName, hashValue }; 
            break;
        }
    }
    return result;
}

std::string MalwareScan::computeHash(const std::string& filePath, const std::string& algo)
{
    const EVP_MD* md = nullptr;
    if (algo == "md5") md = EVP_md5();
    else if (algo == "sha1") md = EVP_sha1();
    else if (algo == "sha256") md = EVP_sha256();

    EVP_MD_CTX* ctx = EVP_MD_CTX_new();
    if (!ctx) return "";

    std::ifstream file(filePath, std::ios::binary);
    if (!file.is_open())
    {
        EVP_MD_CTX_free(ctx);
        return "";
    }

    EVP_DigestInit_ex(ctx, md, nullptr);

    const int kBufferSize = 4096;
    char buffer[kBufferSize];
    while (file)
    {
        file.read(buffer, sizeof(buffer));
        std::streamsize bytesRead = file.gcount();
        if (bytesRead > 0)
        {
            EVP_DigestUpdate(ctx, buffer, bytesRead);
        }
    }

    unsigned char hash[EVP_MAX_MD_SIZE];
    unsigned int length = 0;
    EVP_DigestFinal_ex(ctx, hash, &length);
    EVP_MD_CTX_free(ctx);

    std::stringstream ss;
    for (unsigned int i = 0; i < length; ++i)
    {
        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(hash[i]);
    }
    ss << std::dec;
    return ss.str();
}

static int yara_callback(int msg, void* message_data, void* user_data)
{
    if (msg == CALLBACK_MSG_RULE_MATCHING)
    {
        const YR_RULE* rule = static_cast<const YR_RULE*>(message_data);
        std::string* result = static_cast<std::string*>(user_data);
        *result = rule->identifier;
        return CALLBACK_ABORT;
    }
    return CALLBACK_CONTINUE;
}

DetectResult MalwareScan::matchYaraRules(const std::string& filePath)
{
    if (!mYaraRules)
    {
        return { false, "", "", "" }; 
    }

    YR_SCANNER* scanner = nullptr;
    std::string matchedRule;

    if (yr_scanner_create(mYaraRules, &scanner) != ERROR_SUCCESS)
    {
        return { false, "", "", "" };
    }

    yr_scanner_set_callback(scanner, yara_callback, &matchedRule);

    if (yr_scanner_scan_file(scanner, filePath.c_str()) != ERROR_SUCCESS)
    {
        yr_scanner_destroy(scanner);
        return { false, "", "", "" };
    }

    yr_scanner_destroy(scanner);

    if (!matchedRule.empty())
    {
        return { true, "yara", matchedRule, "" }; 
    }

    return { false, "", "", "" };
}



/*

리포트 및 DB저장

*/
std::string MalwareScan::GenerateReportString()
{
    std::ostringstream ss;

    // 1. 시작 시각
    time_t tStart = std::chrono::system_clock::to_time_t(mStartTime);
    char buf[20];
    strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", localtime(&tStart));
    ss << "[Scan Type] ";

    switch (mMode) {
        case Mode::Manual:    ss << "Manual"; break;
        case Mode::Scheduled: ss << "Scheduled"; break;
        case Mode::Realtime:  ss << "Realtime"; break;
    }
    ss << "\n[Scan Time] " << buf;
    ss << "\n[Scanned Path] " << mDir;

    // 2. 탐지 파일 출력
    ss << "\n\n[Detected Files]";
    for (size_t i = 0; i < mDetected.size(); ++i) {
        const auto& info = mDetected[i];
        bool quarantined = (i < mQuarantineResults.size()) ? mQuarantineResults[i] : false;

        ss << "\n  " << (i + 1) << ". File: " << info.path;

        time_t detectedAt = std::chrono::system_clock::to_time_t(mEndTime);
        strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", localtime(&detectedAt));
        ss << "\n     Detected At: " << buf;
        ss << "\n     Quarantine: " << (quarantined ? "Success" : "Failed");
        ss << "\n     Reason: " << info.cause << " match";

        if (info.cause == "yara")
            ss << "\n     Rule Name: " << info.name;
        else {
            ss << "\n     Hash: " << info.name.substr(0, 24) << "...";
            ss << "\n     Malware Name: " << info.name;
        }

        ss << "\n     Original Size: " << info.size << " bytes";
    }

    // 3. 요약
    ss << "\n\n[Summary]";
    ss << "\nScanned Files: " << mTotalScannedFiles;
    ss << "\nInfected Files: " << mDetected.size();
    ss << "\nQuarantined Files: " << std::count(mQuarantineResults.begin(), mQuarantineResults.end(), true);

    auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(mEndTime - mStartTime).count();
    ss << "\nElapsed Time: " << (elapsed / 60) << ":" << std::setw(2) << std::setfill('0') << (elapsed % 60);
    ss << "\n";

    return ss.str();
}

void MalwareScan::PrintReport(std::ostream& out) const
{
    out << mReport;
}

void MalwareScan::SendNotification() const
{
    const int detected = static_cast<int>(mDetected.size());

    // 수동 검사일 경우 알림 전송 안 함
    if (mMode == Mode::Manual)
        return;

    // 실시간 검사인데 탐지 안 됨 → 전송 안 함
    if (mMode == Mode::Realtime && detected == 0)
        return;

    std::string title;
    std::string message;

    if (mMode == Mode::Scheduled)
    {
        if (detected == 0)
        {
            title = "ManLab 예약 검사 완료";
            message = "악성코드가 탐지되지 않았습니다.";
            UserNotifier::NotifyAll(title, message);
        }
        else
        {
            title = "ManLab 예약 검사 경고";
            message = "총 " + std::to_string(detected) + "개의 악성코드가 탐지되었습니다.";
            UserNotifier::NotifyAllUrgent(title, message);
        }
    }
    else if (mMode == Mode::Realtime)
    {
        title = "ManLab 실시간 탐지 경고";
        message = "총 " + std::to_string(detected) + "개의 악성코드가 탐지되었습니다.";
        UserNotifier::NotifyAllUrgent(title, message);
    }
}

void MalwareScan::SaveReportToDB()
{
    std::string typeStr;
    switch (mMode) {
        case Mode::Manual:    typeStr = "manual"; break;
        case Mode::Scheduled: typeStr = "scheduled"; break;
        case Mode::Realtime:  typeStr = "realtime"; break;
    }

    time_t t = std::chrono::system_clock::to_time_t(mEndTime);
    char buf[20];
    strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S", localtime(&t));

    // ScanReport 삽입
    DBManager::GetInstance().GetScanReportStorage().insert(
        ScanReport {
            0,
            typeStr,
            std::string(buf),
            mReport,
            !mDetected.empty()
        }
    );
}
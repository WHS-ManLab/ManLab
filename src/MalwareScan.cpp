#include "MalwareScan.h"
#include "QuarantineManager.h"

extern "C" {
    #include <yara.h>
}
#include "INIReader.h"

#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <iomanip>
#include <openssl/evp.h>
#include <sqlite3.h>
#include <indicator.hpp>
#include <thread> // std::this_thread::sleep_for
#include <chrono> // std::chrono::milliseconds

using namespace std;
namespace fs = std::filesystem;

static std::string trim(const std::string& s) { //유틸로 통합 예정 
    size_t start = s.find_first_not_of(" \t\r\n");
    size_t end   = s.find_last_not_of(" \t\r\n");
    return (start == std::string::npos) ? "" : s.substr(start, end - start + 1);
}

MalwareScan::MalwareScan()
{
    // 1. INI 파일 파싱
    const std::string iniPath = "/ManLab/conf/MalScanConfig.ini";
    INIReader reader(iniPath);

    if (reader.ParseError() != 0) {
        mDir              = "/home";              // 기본값
        mMaxSize          = 100LL * 1024 * 1024;   // 100 MB
        mShouldQuarantine = false;
    } else {
        // [Scan] paths
        mDir = trim(reader.Get("Scan", "paths", "/home"));

        // [Exclude] paths (쉼표 구분)
        std::string rawExclude = reader.Get("Exclude", "paths", "");
        std::stringstream ss(rawExclude);
        std::string token;
        while (std::getline(ss, token, ',')) {
            std::string cleaned = trim(token);
            if (!cleaned.empty()) {
                mExceptionDir.push_back(cleaned);
            }
        }

        // [Limit] max_size = 100 (MB 단위)
        long long mb = reader.GetInteger("Limit", "max_size", 100);
        mMaxSize = mb * 1024 * 1024;

        // [Quarantine] enable = true|false
        std::string q = trim(reader.Get("Quarantine", "enable", "false"));
        mShouldQuarantine = (q == "true");
    }

    // 2. DB 핸들러 초기화
    mHashStorage = &DBManager::GetInstance().GetHashStorage();

    // 3. YARA 초기화 및 컴파일
    if (yr_initialize() != ERROR_SUCCESS) {
        // TODO: 에러 로그
        return;
    }

    YR_COMPILER* compiler = nullptr;
    if (yr_compiler_create(&compiler) != ERROR_SUCCESS) {
        // TODO: 에러 로그
        return;
    }

    const std::string ruleDir = "/ManLab/rules";
    for (const auto& entry : fs::directory_iterator(ruleDir)) {
        if (!entry.is_regular_file()) continue;
        // malware_hashes.txt 파일은 YARA 룰이 아니므로 건너뜁니다.
        if (entry.path().filename() == "malware_hashes.txt") continue;

        FILE* ruleFile = fopen(entry.path().c_str(), "r");
        if (!ruleFile) continue;

        if (yr_compiler_add_file(compiler, ruleFile, nullptr, entry.path().c_str()) != 0) {
            // TODO: 에러 로그
        }
        fclose(ruleFile);
    }

    if (yr_compiler_get_rules(compiler, &mYaraRules) != ERROR_SUCCESS) {
        // TODO: 에러 로그
        mYaraRules = nullptr;
    }
    yr_compiler_destroy(compiler);
}

MalwareScan::~MalwareScan()
{
    if (mYaraRules) yr_rules_destroy(mYaraRules);
    yr_finalize();
}

void MalwareScan::run()
{
    std::vector<fs::directory_entry> entries;

    try {
        for (const auto& entry : fs::recursive_directory_iterator(mDir)) {
            std::string filePath = entry.path().string();

            // 예외 디렉토리로 시작하는 경우 탐색 자체를 막음
            bool isExcluded = false;
            for (const auto& excludeDir : mExceptionDir) {
                if (filePath.rfind(excludeDir, 0) == 0) {
                    isExcluded = true;
                    break;
                }
            }

            if (isExcluded) continue;

            if (entry.is_regular_file()) {
                entries.push_back(entry);
            }
        }
    } catch (const fs::filesystem_error& e) {
        std::cerr << "\033[31m[!] Filesystem error during scan: " << e.what() << "\033[0m" << std::endl;
    }

    const size_t totalFiles = entries.size();
    if (totalFiles == 0) {
        std::cerr << "\033[31m[!] No files to scan in directory: " << mDir << "\033[0m" << std::endl;
        return;
    }

    indicators::ProgressBar bar{
        indicators::option::BarWidth{50},
        indicators::option::Start{"["},
        indicators::option::Fill{"■"},
        indicators::option::Lead{">"},
        indicators::option::Remainder{"-"},
        indicators::option::End{"]"},
        indicators::option::ForegroundColor{indicators::Color::green},
        indicators::option::ShowPercentage{true},
        indicators::option::ShowElapsedTime{true},
        indicators::option::ShowRemainingTime{true},
        indicators::option::Stream{std::cerr}
    };

    size_t current = 0;

    for (const auto& entry : entries) {
        ++current;

        std::string filePath = entry.path().string();
        long long fileSize = entry.file_size();

        // 파일 크기 체크
        if (fileSize > mMaxSize) {
            if (current % 10 == 0 || current == totalFiles)
                bar.set_progress(100.0f * current / totalFiles);
            continue;
        }

        ++mTotalScannedFiles;

        DetectResult result = detectByHash(filePath);
        if (!result.detected) {
            result = matchYaraRules(filePath);
        }

        if (result.detected) {
            mScanInfo.push_back({ filePath, result.cause, result.malwareName, fileSize });
        }

        if (current % 10 == 0 || current == totalFiles)
            bar.set_progress(100.0f * current / totalFiles);
    }

    std::cerr << std::endl;

    // 격리 수행
    if (mShouldQuarantine && !mScanInfo.empty()) {
        QuarantineManager qm(mScanInfo);
        qm.run();
        mQuarantineResults = qm.GetIsQuarantineSuccess();
    }
}

int MalwareScan::getTotalScannedFiles() const { return mTotalScannedFiles; }
int MalwareScan::getDetectedFiles()     const { return static_cast<int>(mScanInfo.size()); }
int MalwareScan::getQuarantinedFiles()  const {
    return static_cast<int>(std::count(mQuarantineResults.begin(), mQuarantineResults.end(), true));
}
const std::vector<ScanInfo>& MalwareScan::getDetectionResults() const { return mScanInfo; }
const std::string& MalwareScan::getScanRootPath() const { return mDir; }
const std::vector<bool>& MalwareScan::getQuarantineResults() const { return mQuarantineResults; }


//내부 유틸리티 구현
DetectResult MalwareScan::detectByHash(const std::string& filePath)
{
    static const std::vector<std::string> kAlgorithms = { "md5", "sha1", "sha256" };
    DetectResult result { false, "", "" };

    if (!mHashStorage) {
        // TODO: 에러 로그
        return result;
    }

    for (const auto& algo : kAlgorithms) {
        std::string hashValue = computeHash(filePath, algo);
        if (hashValue.empty()) continue;

        auto matches = mHashStorage->get_all<MalwareHashDB>(
            sqlite_orm::where(
                sqlite_orm::c(&MalwareHashDB::Algorithm)    == algo &&
                sqlite_orm::c(&MalwareHashDB::Hash) == hashValue
            )
        );

        if (!matches.empty()) {
            result = { true, algo, matches[0].malwareName };
            break;
        }
    }
    return result;
}

std::string MalwareScan::computeHash(const std::string& filePath, const std::string& algo)
{
    const EVP_MD* md = nullptr;
    if (algo == "md5")      md = EVP_md5();
    else if (algo == "sha1") md = EVP_sha1();
    else if (algo == "sha256") md = EVP_sha256();

    EVP_MD_CTX* ctx = EVP_MD_CTX_new();
    if (!ctx) return "";

    std::ifstream file(filePath, std::ios::binary);
    if (!file.is_open()) {
        EVP_MD_CTX_free(ctx);
        return "";
    }

    EVP_DigestInit_ex(ctx, md, nullptr);

    const int kBufferSize = 4096;
    char buffer[kBufferSize];
    while (file) {
        file.read(buffer, sizeof(buffer));
        std::streamsize bytesRead = file.gcount();
        if (bytesRead > 0) {
            EVP_DigestUpdate(ctx, buffer, bytesRead);
        }
    }

    unsigned char hash[EVP_MAX_MD_SIZE];
    unsigned int length = 0;
    EVP_DigestFinal_ex(ctx, hash, &length);
    EVP_MD_CTX_free(ctx);

    std::stringstream ss;
    for (unsigned int i = 0; i < length; ++i) {
        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(hash[i]);
    }
    ss << std::dec;
    return ss.str();
}

static int yara_callback(int msg, void* message_data, void* user_data)
{
    if (msg == CALLBACK_MSG_RULE_MATCHING) {
        const YR_RULE* rule = static_cast<const YR_RULE*>(message_data);
        std::string* result = static_cast<std::string*>(user_data);
        *result = rule->identifier;
        return CALLBACK_ABORT; // 첫 매칭에서 즉시 중단
    }
    return CALLBACK_CONTINUE;
}

DetectResult MalwareScan::matchYaraRules(const std::string& filePath)
{
    if (!mYaraRules) {
        // TODO: 에러 로그
        return { false, "", "" };
    }

    YR_SCANNER* scanner = nullptr;
    std::string matchedRule;

    if (yr_scanner_create(mYaraRules, &scanner) != ERROR_SUCCESS) {
        // TODO: 에러 로그
        return { false, "", "" };
    }

    yr_scanner_set_callback(scanner, yara_callback, &matchedRule);

    if (yr_scanner_scan_file(scanner, filePath.c_str()) != ERROR_SUCCESS) {
        // TODO: 에러 로그
        yr_scanner_destroy(scanner);
        return { false, "", "" };
    }

    yr_scanner_destroy(scanner);

    if (!matchedRule.empty()) {
        return { true, "yara", matchedRule };
    }
    return { false, "", "" };
}

#include "MalwareScan.h"

#include "QuarantineManager.h"
#include "StringUtils.h"

using manlab::utils::trim;

extern "C" {
    #include <yara.h>
}

#include "INIReader.h"

#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <iomanip>
#include <openssl/evp.h>
#include <sqlite3.h>
#include <indicator.hpp>
#include <thread> // std::this_thread::sleep_for
#include <chrono> // std::chrono::milliseconds

using namespace std;
namespace fs = std::filesystem;

MalwareScan::MalwareScan()
{
    const std::string iniPath = "/ManLab/conf/MalScanConfig.ini";
    INIReader reader(iniPath);

    if (reader.ParseError() != 0)
    {
        mDir = "/home";
        mMaxSize = 100LL * 1024 * 1024;
        mbShouldQuarantine = false;
    }
    else
    {
        mDir = trim(reader.Get("Scan", "paths", "/home"));
        std::string rawExclude = reader.Get("Exclude", "paths", "");
        std::stringstream ss(rawExclude);
        std::string token;
        while (std::getline(ss, token, ','))
        {
            std::string cleaned = trim(token);
            if (!cleaned.empty())
            {
                mExceptionDir.push_back(cleaned);
            }
        }

        long long mb = reader.GetInteger("Limit", "max_size", 100);
        mMaxSize = mb * 1024 * 1024;

        std::string q = trim(reader.Get("Quarantine", "enable", "false"));
        mbShouldQuarantine = (q == "true");
    }

    mHashStorage = &DBManager::GetInstance().GetHashStorage();

    if (yr_initialize() != ERROR_SUCCESS)
    {
        return;
    }

    YR_COMPILER* compiler = nullptr;
    if (yr_compiler_create(&compiler) != ERROR_SUCCESS)
    {
        return;
    }

    const std::string ruleDir = "/ManLab/rules";
    for (const auto& entry : fs::directory_iterator(ruleDir))
    {
        if (!entry.is_regular_file()) continue;

        FILE* ruleFile = fopen(entry.path().c_str(), "r");
        if (!ruleFile) continue;

        if (yr_compiler_add_file(compiler, ruleFile, nullptr, entry.path().c_str()) != 0)
        {
            // TODO: 에러 로그
        }
        fclose(ruleFile);
    }

    if (yr_compiler_get_rules(compiler, &mYaraRules) != ERROR_SUCCESS)
    {
        // TODO: 에러 로그
        mYaraRules = nullptr;
    }
    yr_compiler_destroy(compiler);
}

MalwareScan::~MalwareScan()
{
    if (mYaraRules) yr_rules_destroy(mYaraRules);
    yr_finalize();
}

void MalwareScan::Run()
{
    std::vector<fs::directory_entry> entries;

    try
    {
        for (const auto& entry : fs::recursive_directory_iterator(mDir))
        {
            std::string filePath = entry.path().string();

            bool isExcluded = false;
            for (const auto& excludeDir : mExceptionDir)
            {
                if (filePath.rfind(excludeDir, 0) == 0)
                {
                    isExcluded = true;
                    break;
                }
            }

            if (isExcluded) continue;

            if (entry.is_regular_file())
            {
                entries.push_back(entry);
            }
        }
    }
    catch (const fs::filesystem_error& e)
    {
        std::cerr << "\033[31m[!] Filesystem error during scan: " << e.what() << "\033[0m" << std::endl;
    }

    const size_t totalFiles = entries.size();
    if (totalFiles == 0)
    {
        std::cerr << "\033[31m[!] No files to scan in directory: " << mDir << "\033[0m" << std::endl;
        return;
    }

    indicators::ProgressBar bar{
        indicators::option::BarWidth{50},
        indicators::option::Start{"["},
        indicators::option::Fill{"■"},
        indicators::option::Lead{">"},
        indicators::option::Remainder{"-"},
        indicators::option::End{"]"},
        indicators::option::ForegroundColor{indicators::Color::green},
        indicators::option::ShowPercentage{true},
        indicators::option::ShowElapsedTime{true},
        indicators::option::ShowRemainingTime{true},
        indicators::option::Stream{std::cerr}
    };

    size_t current = 0;

    for (const auto& entry : entries)
    {
        ++current;

        std::string filePath = entry.path().string();
        long long fileSize = entry.file_size();

        if (fileSize > mMaxSize)
        {
            if (current % 10 == 0 || current == totalFiles)
                bar.set_progress(100.0f * current / totalFiles);
            continue;
        }

        ++mTotalScannedFiles;

        DetectResult result = detectByHash(filePath);
        if (!result.detected)
        {
            result = matchYaraRules(filePath);
        }

        if (result.detected)
        {
            mScanInfo.push_back({ filePath, result.cause, result.malwareName, fileSize });
        }

        if (current % 10 == 0 || current == totalFiles)
            bar.set_progress(100.0f * current / totalFiles);
    }
    
    if (mbShouldQuarantine && !mScanInfo.empty())
    {
        QuarantineManager qm(mScanInfo);
        qm.Run();
        mQuarantineResults = qm.GetIsQuarantineSuccess();
    }
}

DetectResult MalwareScan::detectByHash(const std::string& filePath)
{
    static const std::vector<std::string> kAlgorithms = { "md5", "sha1", "sha256" };
    DetectResult result { false, "", "" };

    if (!mHashStorage)
    {
        return result;
    }

    for (const auto& algo : kAlgorithms)
    {
        std::string hashValue = computeHash(filePath, algo);
        if (hashValue.empty()) continue;

        auto matches = mHashStorage->get_all<MalwareHashDB>(
            sqlite_orm::where(
                sqlite_orm::c(&MalwareHashDB::Algorithm) == algo &&
                sqlite_orm::c(&MalwareHashDB::Hash) == hashValue
            )
        );

        if (!matches.empty())
        {
            result = { true, algo, matches[0].MalwareName };
            break;
        }
    }
    return result;
}

std::string MalwareScan::computeHash(const std::string& filePath, const std::string& algo)
{
    const EVP_MD* md = nullptr;
    if (algo == "md5") md = EVP_md5();
    else if (algo == "sha1") md = EVP_sha1();
    else if (algo == "sha256") md = EVP_sha256();

    EVP_MD_CTX* ctx = EVP_MD_CTX_new();
    if (!ctx) return "";

    std::ifstream file(filePath, std::ios::binary);
    if (!file.is_open())
    {
        EVP_MD_CTX_free(ctx);
        return "";
    }

    EVP_DigestInit_ex(ctx, md, nullptr);

    const int kBufferSize = 4096;
    char buffer[kBufferSize];
    while (file)
    {
        file.read(buffer, sizeof(buffer));
        std::streamsize bytesRead = file.gcount();
        if (bytesRead > 0)
        {
            EVP_DigestUpdate(ctx, buffer, bytesRead);
        }
    }

    unsigned char hash[EVP_MAX_MD_SIZE];
    unsigned int length = 0;
    EVP_DigestFinal_ex(ctx, hash, &length);
    EVP_MD_CTX_free(ctx);

    std::stringstream ss;
    for (unsigned int i = 0; i < length; ++i)
    {
        ss << std::hex << std::setw(2) << std::setfill('0') << static_cast<int>(hash[i]);
    }
    ss << std::dec;
    return ss.str();
}

static int yara_callback(int msg, void* message_data, void* user_data)
{
    if (msg == CALLBACK_MSG_RULE_MATCHING)
    {
        const YR_RULE* rule = static_cast<const YR_RULE*>(message_data);
        std::string* result = static_cast<std::string*>(user_data);
        *result = rule->identifier;
        return CALLBACK_ABORT;
    }
    return CALLBACK_CONTINUE;
}

DetectResult MalwareScan::matchYaraRules(const std::string& filePath)
{
    if (!mYaraRules)
    {
        return { false, "", "" };
    }

    YR_SCANNER* scanner = nullptr;
    std::string matchedRule;

    if (yr_scanner_create(mYaraRules, &scanner) != ERROR_SUCCESS)
    {
        return { false, "", "" };
    }

    yr_scanner_set_callback(scanner, yara_callback, &matchedRule);

    if (yr_scanner_scan_file(scanner, filePath.c_str()) != ERROR_SUCCESS)
    {
        yr_scanner_destroy(scanner);
        return { false, "", "" };
    }

    yr_scanner_destroy(scanner);

    if (!matchedRule.empty())
    {
        return { true, "yara", matchedRule };
    }

    return { false, "", "" };
}

void MalwareScan::PrintReport(const std::chrono::system_clock::time_point& startTime,
                               const std::chrono::system_clock::time_point& endTime) const
{
    using namespace std::chrono;

    // 경과 시간 계산
    seconds elapsed = duration_cast<seconds>(endTime - startTime);
    int minutes = elapsed.count() / 60;
    int seconds = elapsed.count() % 60;

    // 시작 시각 문자열 포맷
    time_t now = system_clock::to_time_t(startTime);
    tm* localTime = localtime(&now);
    char timeBuffer[20];
    strftime(timeBuffer, sizeof(timeBuffer), "%Y-%m-%d %H:%M:%S", localTime);

    cout << "\n[Scan Type] Manual" << endl;
    cout << "[Scan Time] " << timeBuffer << endl;
    cout << "[Scanned Path] " << mDir << endl;

    cout << "\n[Detected Files]" << endl;
    for (size_t i = 0; i < mScanInfo.size(); ++i)
    {
        const ScanInfo& info = mScanInfo[i];
        bool isQuarantined = (i < mQuarantineResults.size()) ? mQuarantineResults[i] : false;

        string prefix = isQuarantined ? "\033[31m" : "";
        string suffix = isQuarantined ? "\033[0m" : "";

        cout << prefix;
        cout << "  " << (i + 1) << ". File: " << info.path << endl;

        time_t detectTimeRaw = system_clock::to_time_t(system_clock::now());
        tm* detectTm = localtime(&detectTimeRaw);
        char detectTime[20];
        strftime(detectTime, sizeof(detectTime), "%Y-%m-%d %H:%M:%S", detectTm);
        cout << "     Detected At: " << detectTime << endl;

        cout << "     Quarantine: " << (isQuarantined ? "Success" : "Failed") << endl;
        cout << "     Reason: " << info.cause << " match" << endl;

        if (info.cause == "yara")
        {
            cout << "     Rule Name: " << info.name << endl;
        }
        else
        {
            cout << "     Hash: " << info.name.substr(0, 24) << "..." << endl;
            cout << "     Malware Name: " << info.name << endl;
        }

        cout << "     Original Size: " << info.size << " bytes" << endl;
        cout << suffix;
    }

    cout << "\n[Summary]" << endl;
    cout << "Scanned Files: " << mTotalScannedFiles << endl;
    cout << "Infected Files: " << mScanInfo.size() << endl;
    cout << "Quarantined Files: "
         << count(mQuarantineResults.begin(), mQuarantineResults.end(), true) << endl;
    cout << "Elapsed Time: " << setfill('0') << setw(2) << minutes
         << ":" << setw(2) << seconds << endl;
}

// 리팩토링,  예정
// 1. 매 파일마다 DB 열고 닫기 → I/O 오버헤드 큼. 
// RAII 래퍼를 멤버로 두고 한 번만 열기.
//
// 2. 모든 파일마다 룰 디렉터리를 다시 컴파일 → 매우 느림.
// YR_RULES 를 싱글턴/정적으로 캐시.
// 초기화(yr_initialize) 는 프로그램 시작 한 번.
//
// 3. 스레드 추가 및 스레드 진입 시 락 걸기
//
// 수정
// 1. 리포트 추가
// 2. 격리 실패 시 로직 추가가

#include "ScanMalware.h"
#include "QuarantineManager.h"

extern "C" {
    #include "ini.h"
}
#include "INIReader.h"

#include <filesystem>
#include <fstream>
#include <iostream>
#include <unordered_map>
#include <map>
#include <vector>
#include <string>
#include <sstream>
#include <algorithm>
#include <openssl/evp.h>
#include <iomanip>
#include <sqlite3.h>
#include <yara.h>

using namespace std;
namespace fs = std::filesystem;

ScanMalware::ScanMalware(string dir, vector<string> exceptionDir, long long maxSize)
    : m_dir(move(dir)), m_exceptionDir(move(exceptionDir)), m_maxSize(maxSize)
{
}

vector<string> ScanMalware::getMalwareFiles() const
{
    return m_malwareFiles;
}

// 문자열을 ',' 기준으로 split
static vector<string> splitAndTrim(const string& str)
{
    vector<string> result;
    istringstream ss(str);
    string token;

    while (getline(ss, token, ','))
    {
        token.erase(remove_if(token.begin(), token.end(), ::isspace), token.end());
        if (!token.empty())
            result.push_back(token);
    }

    return result;
}

void ScanMalware::run()
{
    // 1. 격리 설정 파일 로드
    INIReader quarantineReader("/Manlab/conf/SIGQuarantine.ini");
    string quarantineFlag = quarantineReader.Get("Quarantine", "enable", "false");
    bool shouldQuarantine = (quarantineFlag == "true");

    // 2. 탐지 결과 저장용 벡터
    vector<string> detectedFiles;
    vector<string> causeTypes;
    vector<string> malwareNamesOrRules;
    vector<long long> fileSizes;

    for (const auto& entry : fs::recursive_directory_iterator(m_dir))
    {
        if (!entry.is_regular_file())
            continue;

        string filePath = entry.path().string();
        long long fileSize = entry.file_size();

        // 3. 예외 필터링 (m_exceptionDir 사용)
        bool isExcluded = false;
        for (const auto& excludeDir : m_exceptionDir)
        {
            if (filePath.rfind(excludeDir, 0) == 0)
            {
                isExcluded = true;
                break;
            }
        }

        if (isExcluded || fileSize > m_maxSize)
            continue;

        // 4. 해시 검사    
        DetectResult result = detectByHash(filePath);

        // 5. YARA 룰 검사
        if (!result.detected)
        {
            string ruleName = matchYaraRules(filePath);
            if (!ruleName.empty())
            {
                result.detected = true;
                result.cause = "yara";
                result.malwareName = ruleName;
            }
        }

        // 6. 결과 저장
        if (result.detected)
        {
            detectedFiles.push_back(filePath);
            causeTypes.push_back(result.cause);
            malwareNamesOrRules.push_back(result.malwareName);
            fileSizes.push_back(fileSize);

            cout << "DEBUG: " << filePath << "  " << result.cause << "  " << result.malwareName << endl;
        }
    }

    // 7. 격리 수행
    if (shouldQuarantine && !detectedFiles.empty())
    {
        QuarantineManager qm(detectedFiles, causeTypes, malwareNamesOrRules, fileSizes);
        qm.Run();
        vector<bool> success = qm.GetIsQuarantineSuccess();
    }
    // TODO: Reporting logic
    m_malwareFiles = detectedFiles;
    return ;
}

/*
CREATE TABLE malware_hashes (
    algo TEXT,            
    hash TEXT PRIMARY KEY,
    name TEXT
);
*/
string ScanMalware::computeHash(const string& filePath, const string& algo)
{
    const EVP_MD* md = nullptr;

    if (algo == "md5") md = EVP_md5();
    else if (algo == "sha1") md = EVP_sha1();
    else if (algo == "sha256") md = EVP_sha256();

    //OpenSSL 해시 컨택스트
    EVP_MD_CTX* ctx = EVP_MD_CTX_new();
    if (!ctx) return "";

    ifstream file(filePath, ios::binary);
    if (!file.is_open())
    {
        EVP_MD_CTX_free(ctx);
        return "";
    }

    //초기화
    EVP_DigestInit_ex(ctx, md, nullptr);

    const int kBufferSize = 4096;
    char buffer[kBufferSize];
    while (file)
    {
        file.read(buffer, sizeof(buffer));
        streamsize bytesRead = file.gcount();
        if (bytesRead > 0)
            EVP_DigestUpdate(ctx, buffer, bytesRead);
    }

    unsigned char hash[EVP_MAX_MD_SIZE];
    unsigned int length = 0;
    EVP_DigestFinal_ex(ctx, hash, &length);
    EVP_MD_CTX_free(ctx);

    stringstream ss;
    for (unsigned int i = 0; i < length; ++i)
        ss << hex << setw(2) << setfill('0') << static_cast<int>(hash[i]); //binary to hex
    ss << std::dec;

    return ss.str(); //해시 값
}

DetectResult ScanMalware::detectByHash(const string& filePath)
{
    const vector<string> kAlgorithms = { "md5", "sha1", "sha256" };

    sqlite3* db = nullptr;
    const string kDbPath = fs::absolute("../db/hash.db").string();

    if (sqlite3_open(kDbPath.c_str(), &db) != SQLITE_OK)
    {
        cerr << "SQLite open error: " << sqlite3_errmsg(db) << endl;
        return { false, "", "" };
    }

    const string kQuery = "SELECT name FROM malware_hashes WHERE algo = ? AND hash = ?";
    sqlite3_stmt* stmt = nullptr;

    DetectResult result = { false, "", "" };

    for (const auto& algo : kAlgorithms)
    {
        string hashValue = computeHash(filePath, algo);
        if (hashValue.empty())
            continue;

        if (sqlite3_prepare_v2(db, kQuery.c_str(), -1, &stmt, nullptr) != SQLITE_OK)
        {
            cerr << "SQLite prepare error: " << sqlite3_errmsg(db) << endl;
            continue;  // DB 열려 있으므로 다음 해시 알고리즘으로 넘어감
        }

        // 파라미터 바인딩
        sqlite3_bind_text(stmt, 1, algo.c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 2, hashValue.c_str(), -1, SQLITE_STATIC);

        // 결과 확인
        if (sqlite3_step(stmt) == SQLITE_ROW)
        {
            string malwareName = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0));
            result = { true, algo, malwareName };
            sqlite3_finalize(stmt);
            break;
        }

        sqlite3_finalize(stmt);
        stmt = nullptr;
    }

    sqlite3_close(db);
    return result;
}

int yara_callback(int msg, void* message_data, void* user_data)
{
    if (msg == CALLBACK_MSG_RULE_MATCHING)
    {
        const YR_RULE* rule = static_cast<const YR_RULE*>(message_data);
        string* result = static_cast<string*>(user_data);
        *result = rule->identifier;
        return CALLBACK_ABORT;
    }
    return CALLBACK_CONTINUE;
}

string ScanMalware::matchYaraRules(const string& filePath)
{
    YR_COMPILER* compiler = nullptr;
    YR_RULES* rules = nullptr;
    YR_SCANNER* scanner = nullptr;
    string matchedRule;
    bool success = false;

    if (yr_initialize() != ERROR_SUCCESS)
    {
        cerr << "YARA init failed" << endl;
        return "";
    }

    do {
        // 컴파일러 생성
        if (yr_compiler_create(&compiler) != ERROR_SUCCESS)
        {
            cerr << "YARA compiler create failed" << endl;
            break;
        }

        // 룰 디렉토리 컴파일
        string ruleDir = string(getenv("HOME")) + "/ManLab/rules"; //테스트용 홈 디렉토리
        for (const auto& entry : fs::directory_iterator( ruleDir))
        {
            if (!entry.is_regular_file()) continue;

            string rulePath = entry.path().string();
            FILE* ruleFile = fopen(rulePath.c_str(), "r");
            if (!ruleFile) continue;

            if (yr_compiler_add_file(compiler, ruleFile, nullptr, rulePath.c_str()) != 0)
            {
                cerr << "Failed to compile YARA rule: " << rulePath << endl;
            }

            fclose(ruleFile);
        }

        // 룰 객체 생성
        if (yr_compiler_get_rules(compiler, &rules) != ERROR_SUCCESS)
        {
            cerr << "Failed to get YARA rules" << endl;
            break;
        }

        // 스캐너 생성
        if (yr_scanner_create(rules, &scanner) != ERROR_SUCCESS)
        {
            cerr << "Failed to create YARA scanner" << endl;
            break;
        }

        yr_scanner_set_callback(scanner, yara_callback, &matchedRule);

        // 스캔
        if (yr_scanner_scan_file(scanner, filePath.c_str()) != ERROR_SUCCESS)
        {
            cerr << "YARA scan failed for file: " << filePath << endl;
            break;
        }

        success = true;

    } while (false);

    // 자원 해제 (순서: scanner → rules → compiler → finalize)
    if (scanner) yr_scanner_destroy(scanner);
    if (rules) yr_rules_destroy(rules);
    if (compiler) yr_compiler_destroy(compiler);
    yr_finalize();

    return success ? matchedRule : "";
}



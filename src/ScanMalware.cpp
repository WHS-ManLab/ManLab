#include "ScanMalware.h"
#include "QuarantineManager.h"

extern "C" {
    #include "ini.h"
}
#include "INIReader.h"

#include <filesystem>
#include <fstream>
#include <iostream>
#include <unordered_map>
#include <map>
#include <vector>
#include <string>
#include <sstream>
#include <algorithm>
#include <openssl/evp.h>
#include <iomanip>
#include <sqlite3.h>
#include <yara.h>

using namespace std;
namespace fs = std::filesystem;

ScanMalware::ScanMalware(string dir, vector<string> exceptionDir, long long maxSize)
    : m_dir(move(dir)), m_exceptionDir(move(exceptionDir)), m_maxSize(maxSize)
{
}

vector<string> ScanMalware::getMalwareFiles() const
{
    return m_malwareFiles;
}

// 문자열을 ',' 기준으로 split
static vector<string> splitAndTrim(const string& str)
{
    vector<string> result;
    istringstream ss(str);
    string token;

    while (getline(ss, token, ','))
    {
        token.erase(remove_if(token.begin(), token.end(), ::isspace), token.end());
        if (!token.empty())
            result.push_back(token);
    }

    return result;
}

void ScanMalware::run()
{
    // 1. 예외 설정 파일 로드
    INIReader excludeReader("/Manlab/conf/excludemalwarescan.ini");

    vector<string> excludeDirs = splitAndTrim(excludeReader.Get("SIGScanExecption", "excluded_paths", ""));
    long long excludeMaxSize = excludeReader.GetInteger("SIGScanExecption", "max_size", m_maxSize);

    // 2. 격리 설정 파일 로드
    INIReader quarantineReader("/Manlab/conf/SIGQuarantine.ini");
    string quarantineFlag = quarantineReader.Get("Quarantine", "enable", "false");
    bool shouldQuarantine = (quarantineFlag == "true");

     // 3. 탐지 결과 저장용 벡터
    vector<string> detectedFiles;
    vector<string> causeTypes;
    vector<string> malwareNamesOrRules;
    vector<long long> fileSizes;

    for (const auto& entry : fs::recursive_directory_iterator(m_dir))
    {
        if (!entry.is_regular_file())
            continue;

        string filePath = entry.path().string();
        string extension = entry.path().extension().string();
        long long fileSize = entry.file_size();

        // 4. 예외 필터링
        bool isExcluded = false;
        for (const auto& excludeDir : excludeDirs)
        {
            if (filePath.rfind(excludeDir, 0) == 0)
            {
                isExcluded = true;
                break;
            }
        }

        if (isExcluded || fileSize > m_maxSize)
            continue;

        // 5. 해시 검사    
        DetectResult result = detectByHash(filePath);

        // 6. YARA 룰 검사
        if (!result.detected)
        {
            string ruleName = matchYaraRules(filePath);
            if (!ruleName.empty())
            {
                result.detected = true;
                result.cause = "yara";
                result.malwareName = ruleName;
            }
        }

        // 7. 결과 저장
        if (result.detected)
        {
            detectedFiles.push_back(filePath);
            causeTypes.push_back(result.cause);
            malwareNamesOrRules.push_back(result.malwareName);
            fileSizes.push_back(fileSize);

            cout << "DEBUG: " << filePath << "  " << result.cause << "  " << result.malwareName << endl;
        }
    }

    // 8. 격리 수행
    if (shouldQuarantine && !detectedFiles.empty())
    {
        QuarantineManager qm(detectedFiles, causeTypes, malwareNamesOrRules, fileSizes);
        qm.run();
        vector<bool> success = qm.getisQuarantineSucces();
        m_malwareFiles = detectedFiles;
    }

    // TODO: Reporting logic
}

/*
CREATE TABLE malware_hashes (
    algo TEXT,            
    hash TEXT PRIMARY KEY,
    name TEXT
);
*/
DetectResult detectByHash(const string& filePath)
{
    const vector<string> kAlgorithms = { "md5", "sha1", "sha256" };

    sqlite3* db;
    const string kDbPath = "/Manlab/db/hash.db";
    if (sqlite3_open(kDbPath.c_str(), &db) != SQLITE_OK)
    {
        cerr << "SQLite open error: " << sqlite3_errmsg(db) << endl;
        return { false, "", "" };
    }

    const string kQuery = "SELECT name FROM malware_hashes WHERE algo = ? AND hash = ?";
    sqlite3_stmt* stmt;

    for (const auto& algo : kAlgorithms)
    {
        string hashValue = computeHash(filePath, algo);
        if (hashValue.empty())
            continue;

        if (sqlite3_prepare_v2(db, kQuery.c_str(), -1, &stmt, nullptr) != SQLITE_OK)
        {
            cerr << "SQLite prepare error: " << sqlite3_errmsg(db) << endl;
            sqlite3_close(db);
            return { false, "", "" };
        }

        // 파라미터 바인딩
        sqlite3_bind_text(stmt, 1, algo.c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 2, hashValue.c_str(), -1, SQLITE_STATIC);

        // 결과 확인
        if (sqlite3_step(stmt) == SQLITE_ROW)
        {
            string malwareName = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0));
            sqlite3_finalize(stmt);
            sqlite3_close(db);
            return { true, algo, malwareName };
        }

        sqlite3_finalize(stmt);  // 해제. 추후 리팩토링
    }

    sqlite3_close(db);
    return { false, "", "" };
}

string computeHash(const string& filePath, const string& algo)
{
    const EVP_MD* md = nullptr;

    if (algo == "md5") md = EVP_md5();
    else if (algo == "sha1") md = EVP_sha1();
    else if (algo == "sha256") md = EVP_sha256();

    //OpenSSL 해시 컨택스트
    EVP_MD_CTX* ctx = EVP_MD_CTX_new();
    if (!ctx) return "";

    ifstream file(filePath, ios::binary);
    if (!file.is_open())
    {
        EVP_MD_CTX_free(ctx);
        return "";
    }

    //초기화
    EVP_DigestInit_ex(ctx, md, nullptr);

    const int kBufferSize = 4096;
    char buffer[kBufferSize];
    while (file)
    {
        file.read(buffer, sizeof(buffer));
        streamsize bytesRead = file.gcount();
        if (bytesRead > 0)
            EVP_DigestUpdate(ctx, buffer, bytesRead);
    }

    unsigned char hash[EVP_MAX_MD_SIZE];
    unsigned int length = 0;
    EVP_DigestFinal_ex(ctx, hash, &length);
    EVP_MD_CTX_free(ctx);

    stringstream ss;
    for (unsigned int i = 0; i < length; ++i)
        ss << hex << setw(2) << setfill('0') << static_cast<int>(hash[i]); //binary to hex

    return ss.str(); //해시 값
}

string matchYaraRules(const string& filePath)
{
    YR_COMPILER* compiler = nullptr;
    YR_RULES* rules = nullptr;
    YR_SCANNER* scanner = nullptr;
    string matchedRule;

    // 1. YARA 초기화
    if (yr_initialize() != ERROR_SUCCESS)
    {
        cerr << "YARA init failed" << endl;
        return "";
    }

    // 2. 컴파일러 생성
    if (yr_compiler_create(&compiler) != ERROR_SUCCESS)
    {
        yr_finalize();
        cerr << "YARA compiler create failed" << endl;
        return "";
    }

    // 3. 룰 디렉토리 순회하며 룰 파일 컴파일
    for (const auto& entry : fs::directory_iterator("/Manlab/rules"))
    {
        if (!entry.is_regular_file()) continue;

        string rulePath = entry.path().string();
        FILE* ruleFile = fopen(rulePath.c_str(), "r");
        if (!ruleFile) continue;

        if (yr_compiler_add_file(compiler, ruleFile, nullptr, rulePath.c_str()) != 0)
            cerr << "Failed to compile YARA rule: " << rulePath << endl;

        fclose(ruleFile);
    }

    // 4. 컴파일된 룰을 RULES 객체로 생성
    if (yr_compiler_get_rules(compiler, &rules) != ERROR_SUCCESS)
    {
        yr_compiler_destroy(compiler);
        yr_finalize();
        return "";
    }

    // 5. SCANNER 객체 생성 및 룰 바인딩
    if (yr_scanner_create(rules, &scanner) != ERROR_SUCCESS)
    {
        yr_rules_destroy(rules);
        yr_compiler_destroy(compiler);
        yr_finalize();
        return "";
    }

     // 6. 콜백 함수 정의 (첫 매칭된 룰 이름 저장)
    auto callback = [](YR_SCAN_CONTEXT* ctx, int msg, void* message_data, void* user_data) -> int
    {
        if (msg == CALLBACK_MSG_RULE_MATCHING)
        {
            const YR_RULE* rule = static_cast<const YR_RULE*>(message_data);
            string* result = static_cast<string*>(user_data);
            *result = rule->identifier;
            return CALLBACK_ABORT;
        }
        return CALLBACK_CONTINUE;
    };

    yr_scanner_set_callback(scanner, callback, &matchedRule);

    // 7. 파일 스캔
    if (yr_scanner_scan_file(scanner, filePath.c_str()) != ERROR_SUCCESS)
    {
        cerr << "YARA scan failed for file: " << filePath << endl;
    }

    // 8. 정리
    yr_scanner_destroy(scanner);
    yr_rules_destroy(rules);
    yr_compiler_destroy(compiler);
    yr_finalize();

    return matchedRule;
}

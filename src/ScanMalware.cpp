#include "ScanMalware.h"
#include "QuarantineManager.h"

extern "C" {
    #include "ini.h"
    #include <yara.h>
}
#include "INIReader.h"

#include <filesystem>
#include <fstream>
#include <iostream>
#include <sstream>
#include <algorithm>
#include <iomanip>
#include <openssl/evp.h>
#include <sqlite3.h>

using namespace std;
namespace fs = std::filesystem;

ScanMalware::ScanMalware(string dir, vector<string> exceptionDir, long long maxSize)
    : m_dir(move(dir)), m_exceptionDir(move(exceptionDir)), m_maxSize(maxSize)
{
    // 악성코드 해시 DB 열기
    const string kDbPath = fs::absolute("../db/hash.db").string();
    if (sqlite3_open(kDbPath.c_str(), &m_db) != SQLITE_OK)
    {
        cerr << "SQLite open error: " << sqlite3_errmsg(m_db) << endl;
        m_db = nullptr;
    }

    // YARA 초기화
    if (yr_initialize() != ERROR_SUCCESS)
    {
        cerr << "YARA init failed" << endl;
        return;
    }

    // YARA 컴파일러 생성
    YR_COMPILER* compiler = nullptr;
    if (yr_compiler_create(&compiler) != ERROR_SUCCESS)
    {
        cerr << "YARA compiler create failed" << endl;
        return;
    }

    // 사용자 홈 디렉토리의 룰 디렉토리 지정
    string ruleDir = string(getenv("HOME")) + "/ManLab/rules";
    
    // 모든 .yar 룰 파일 컴파일 시도
    for (const auto& entry : fs::directory_iterator(ruleDir))
    {
        if (!entry.is_regular_file()) continue;

        string rulePath = entry.path().string();
        FILE* ruleFile = fopen(rulePath.c_str(), "r");
        if (!ruleFile) continue;

        // 컴파일 실패한 룰만 로그 출력하고 무시
        if (yr_compiler_add_file(compiler, ruleFile, nullptr, rulePath.c_str()) != 0)
        {
            cerr << "Failed to compile YARA rule: " << rulePath << endl;
        }

        fclose(ruleFile);
    }

    // 컴파일된 룰을 rules 객체로 추출
    if (yr_compiler_get_rules(compiler, &m_yaraRules) != ERROR_SUCCESS)
    {
        cerr << "Failed to get YARA rules" << endl;
        m_yaraRules = nullptr;
    }

    // 컴파일러 객체 제거
    yr_compiler_destroy(compiler);
}

ScanMalware::~ScanMalware()
{
    if (m_db) sqlite3_close(m_db);
    if (m_yaraRules) yr_rules_destroy(m_yaraRules);
    yr_finalize();
}

void ScanMalware::run()
{
    // 격리 설정 파일에서 enable 여부 확인
    string home = getenv("HOME");
    string quarantinePath = home + "/ManLab/conf/SIGQuarantine.ini";
    INIReader quarantineReader(quarantinePath);
    string quarantineFlag = quarantineReader.Get("Quarantine", "enable", "false");
    bool shouldQuarantine = (quarantineFlag == "true");

    // 검사 대상 디렉토리 순회
    for (const auto& entry : fs::recursive_directory_iterator(m_dir))
    {
        if (!entry.is_regular_file()) continue;

        string filePath = entry.path().string();
        long long fileSize = entry.file_size();

        // 예외 디렉토리 여부 확인
        bool isExcluded = false;
        for (const auto& excludeDir : m_exceptionDir)
        {
            if (filePath.rfind(excludeDir, 0) == 0) // excludeDir로 시작하는 경우
            {
                isExcluded = true;
                break;
            }
        }

        // 예외 또는 파일 크기 초과 시 검사 제외
        if (isExcluded || fileSize > m_maxSize) continue;

        ++m_totalScannedFiles;

        // 해시 기반 탐지
        DetectResult result = detectByHash(filePath);

        // 해시 탐지 실패 시 YARA 검사
        if (!result.detected)
        {
            result = matchYaraRules(filePath);
        }

        // 탐지되었으면 결과 저장 (격리 여부는 나중에 설정)
        if (result.detected)
        {
            m_detectionResults.push_back({ filePath, result.cause, result.malwareName, fileSize, false });
        }
    }

    // 격리 설정이 활성화되어 있고 탐지된 항목이 있을 경우
    if (shouldQuarantine && !m_detectionResults.empty())
    {
        // QuarantineManager를 위한 정보 분리
        vector<string> paths;
        vector<string> causes;
        vector<string> names;
        vector<long long> sizes;

        for (const auto& r : m_detectionResults)
        {
            paths.push_back(r.path);
            causes.push_back(r.cause);
            names.push_back(r.name);
            sizes.push_back(r.size);
        }

        // 격리 수행
        QuarantineManager qm(paths, causes, names, sizes);
        qm.Run();
        vector<bool> results = qm.GetIsQuarantineSuccess();

        // 격리 결과 반영
        for (size_t i = 0; i < results.size() && i < m_detectionResults.size(); ++i)
            m_detectionResults[i].quarantined = results[i];
    }
}


int ScanMalware::getTotalScannedFiles() const
{
    return m_totalScannedFiles;
}

int ScanMalware::getDetectedFiles() const
{
    return static_cast<int>(m_detectionResults.size());
}

int ScanMalware::getQuarantinedFiles() const
{
    int count = 0;
    for (const auto& r : m_detectionResults)
        if (r.quarantined) ++count;
    return count;
}

const vector<DetectionResultRecord>& ScanMalware::getDetectionResults() const
{
    return m_detectionResults;
}

DetectResult ScanMalware::detectByHash(const string& filePath)
{
    // 사용할 해시 알고리즘 목록 
    const vector<string> kAlgorithms = { "md5", "sha1", "sha256" };

    // DB 미초기화 시 탐지 실패 처리
    if (!m_db)
    {
        cerr << "SQLite not initialized." << endl;
        return { false, "", "" };
    }

    // 해시 탐지를 위한 SQL 쿼리 템플릿
    const string kQuery = "SELECT name FROM malware_hashes WHERE algo = ? AND hash = ?";
    sqlite3_stmt* stmt = nullptr;
    DetectResult result = { false, "", "" };

    // 각 알고리즘에 대해 순차적으로 해시 검사
    for (const auto& algo : kAlgorithms)
    {
        // 대상 파일의 해시값 계산
        string hashValue = computeHash(filePath, algo);
        if (hashValue.empty()) continue;

        // SQL 쿼리 준비
        if (sqlite3_prepare_v2(m_db, kQuery.c_str(), -1, &stmt, nullptr) != SQLITE_OK)
        {
            cerr << "SQLite prepare error: " << sqlite3_errmsg(m_db) << endl;
            continue;
        }

        // 쿼리 파라미터 바인딩: 1 → 알고리즘, 2 → 해시값
        sqlite3_bind_text(stmt, 1, algo.c_str(), -1, SQLITE_STATIC);
        sqlite3_bind_text(stmt, 2, hashValue.c_str(), -1, SQLITE_STATIC);

        // 결과 확인: 매칭되는 악성 해시가 있으면 탐지 성공 처리
        if (sqlite3_step(stmt) == SQLITE_ROW)
        {
            string malwareName = reinterpret_cast<const char*>(sqlite3_column_text(stmt, 0));
            result = { true, algo, malwareName };
            sqlite3_finalize(stmt); // 매칭 시 즉시 리소스 정리하고 루프 종료
            break;
        }

        // 매칭 실패한 경우에도 리소스 해제
        sqlite3_finalize(stmt);
        stmt = nullptr;
    }

    return result;
}

string ScanMalware::computeHash(const string& filePath, const string& algo)
{
    // 선택한 해시 알고리즘에 대응하는 OpenSSL digest 함수 포인터
    const EVP_MD* md = nullptr;
    if (algo == "md5") md = EVP_md5();
    else if (algo == "sha1") md = EVP_sha1();
    else if (algo == "sha256") md = EVP_sha256();

    // Digest 컨텍스트 생성
    EVP_MD_CTX* ctx = EVP_MD_CTX_new();
    if (!ctx) return ""; // 메모리 부족 등 오류 시 실패 처리

    // 바이너리 모드로 파일 열기
    ifstream file(filePath, ios::binary);
    if (!file.is_open())
    {
        EVP_MD_CTX_free(ctx);
        return ""; // 파일 열기 실패 시 빈 문자열 반환
    }

    // Digest 초기화
    EVP_DigestInit_ex(ctx, md, nullptr);

    // 파일을 4KB씩 읽으며 해시 갱신
    const int kBufferSize = 4096;
    char buffer[kBufferSize];
    while (file)
    {
        file.read(buffer, sizeof(buffer));
        streamsize bytesRead = file.gcount();
        if (bytesRead > 0)
            EVP_DigestUpdate(ctx, buffer, bytesRead);
    }

    // 최종 해시 계산
    unsigned char hash[EVP_MAX_MD_SIZE];
    unsigned int length = 0;
    EVP_DigestFinal_ex(ctx, hash, &length);

    // 컨텍스트 해제
    EVP_MD_CTX_free(ctx);

    // 결과를 hex 문자열로 변환
    stringstream ss;
    for (unsigned int i = 0; i < length; ++i)
        ss << hex << setw(2) << setfill('0') << static_cast<int>(hash[i]);
    ss << std::dec;

    return ss.str();
}


int yara_callback(int msg, void* message_data, void* user_data)
{
    if (msg == CALLBACK_MSG_RULE_MATCHING)
    {
        const YR_RULE* rule = static_cast<const YR_RULE*>(message_data);
        string* result = static_cast<string*>(user_data);
        *result = rule->identifier;
        return CALLBACK_ABORT;
    }
    return CALLBACK_CONTINUE;
}

DetectResult ScanMalware::matchYaraRules(const string& filePath)
{
    if (!m_yaraRules)
    {
        cerr << "YARA rules not initialized." << endl;
        return { false, "", "" };
    }

    YR_SCANNER* scanner = nullptr;
    string matchedRule;

    if (yr_scanner_create(m_yaraRules, &scanner) != ERROR_SUCCESS)
    {
        cerr << "Failed to create YARA scanner" << endl;
        return { false, "", "" };
    }

    yr_scanner_set_callback(scanner, yara_callback, &matchedRule);

    if (yr_scanner_scan_file(scanner, filePath.c_str()) != ERROR_SUCCESS)
    {
        cerr << "YARA scan failed for file: " << filePath << endl;
        yr_scanner_destroy(scanner);
        return { false, "", "" };
    }

    yr_scanner_destroy(scanner);

    // 탐지 결과가 있으면 결과 반환
    if (!matchedRule.empty())
        return { true, "yara", matchedRule };

    return { false, "", "" };
}